# 좋은 테스트의 FISRT 속성

- 테스트 코드의 문제점이 생기는 경우
    - 테스트를 사용하는 사람에게 어떤 정보도 주지 못하는 테스트
    - 산발적으로 실패하는 테스트
    - 어떤 가치도 증명하지 못하는 테스트
    - 실행하는 데 오래 걸리는 테스트
    - 코드를 충분히 커버하지 못하는 테스트2
    - 구현과 강하게 결합되어 있는 테스트, 따라서 작은 변화에도 다수의 테스트가 깨짐5t
    - 수많은 설정 고리로 점프하는 난해한 테스트

## FIRST: 좋은 테스트 조건

- [F]ast - 빠르다.
- [I]solated - 고립된
- [R]epeatable - 반복 가능한
- [S]elf-validating - 스스로 검증 가능한
- [T]imely - 적시의



## [F]IRST: 빠르다.
- 시스템이 커지면 단위테스트도 실행하는 데 점점 오래 걸린다.
- 단위 테스트 스위트의 가치는 대상 시스템에 대한 지속적이고 종합적인 빠른 피드백을 주지 못하면 그만큼 저하된다.
- 설계를 깨끗하게 하면 빠르게 유지할 수 있다.
    - 가장 먼저 느린 테스트에 대한 의존성을 줄여라.

## F[I]RST: 고립시킨다.
- 좋은 단위 테스트는 검증하려는 작은 양의 코드에 집중
- 직접적혹은 간접적으로 테스트 코드와 상호 작용하는 코드가 많을수록 문제가 발생할 소지가 늘어남
- 테스트코드는 어떤 순서나 시간에 관계없이 실행할 수 있어야 한다.
- 테스트가 하나 이상의 이유로 깨진다면 테스트를 분할하는 것도 고려해 보자.

## FI[R]ST: 좋은 테스트는 반복 가능해야 한다.
- 반복 가능한 테스트를 만들려면 직접 통제할 수 없는 외부 환경에 있는 항목들과 격리시켜야 한다.
- 테스트 대상 코드의 나머지를 격리하고 시간 변화에 독립성을 유지하는 방법으로 목개체를 사용할 수도 있다.


## FIR[S]T: 스스로 검증 가능하다.
- 기대하는 것이 무엇인지 단언하지 않으면 테스트가 아니다.
- 테스트 결과를 수동으로 검증하는 것은 시간 소모적인 절차고 리스크가 늘어난다.
- CI(Continuous Integration) 도구를 통해 테스트 절차를 자동화할 수있다.

## FIRS[T]: 적시에 사용한다.
- 단위 테스트를 더 많이 할수록 테스트 대상 코드가 줄어든다.
    - 단위테스트 작성이 쉬워진다.
    - 새로운 코드를 넣었을 때 테스트 효과가 즉시 나타난다.
- 옛날 코드에 대한 테스트는 시간 낭비가 될 수도 있다.
    - 코드에 큰 결함이 없고 당장 변경할 예정이 없다면 말썽이 많고 역동적인 부분을 먼저 테스트 하라.
